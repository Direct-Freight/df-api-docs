=begin comment

Direct Freight API

In order to use the Direct Freight API please first contact us to get an API Token. This token needs to be sent as a HTTP header argument in every request to our API.  api-token=\"SECRET KEY\"  Please keep your api-token a secret. If the token is compromised please contact us to get a new one.  This api token authenticates your application and gives it access to the API.  The API token should not be confused with the end-user-token. That token is given to you via the end_user_authentications endpoint when the user logs in. This token is needed in order to use certain features, and get certain sensitive information.  Both Tokens are stateless, and delivered via the HTTP headers.

OpenAPI spec version: 2.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

=end comment

=cut

#
# NOTE: This class is auto generated by the swagger code generator program. 
# Do not edit the class manually.
# Ref: https://github.com/swagger-api/swagger-codegen
#
package WWW::SwaggerClient::BoardsApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::SwaggerClient::ApiClient;
use WWW::SwaggerClient::Configuration;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class   = shift;
    my (%self) = (
        'api_client' => WWW::SwaggerClient::ApiClient->instance,
        @_
    );

    #my $self = {
    #    #api_client => $options->{api_client}
    #    api_client => $default_api_client
    #}; 

    bless \%self, $class;

}


#
# boards_board_type_origin_state_origin_city_origin_radius_load_type_destination_state_destination_city_get
#
# A convenience method for simple searches.
# 
# @param string $board_type This will be specified in the url. Valid types are \&quot;loads\&quot;, and \&quot;trucks\&quot;. (required)
# @param string $origin_state The minimum needed for a search. (required)
# @param string $origin_city Must be at least 2 characters. (required)
# @param int $origin_radius If both city and state, it will search for all entries within # Miles of the city. (required)
# @param string $destination_state If it is an array, we assume a multi state search, and ignore destination_city. (required)
# @param string $destination_city Must be at least 2 characters. (required)
# @param string $load_type A string of comma separated valid trailer types to limit the search. (required)
# @param string $end_user_token Sensitive info like phone numbers won&#39;t be returned without this. (optional)
{
    my $params = {
    'board_type' => {
        data_type => 'string',
        description => 'This will be specified in the url. Valid types are \&quot;loads\&quot;, and \&quot;trucks\&quot;.',
        required => '1',
    },
    'origin_state' => {
        data_type => 'string',
        description => 'The minimum needed for a search.',
        required => '1',
    },
    'origin_city' => {
        data_type => 'string',
        description => 'Must be at least 2 characters.',
        required => '1',
    },
    'origin_radius' => {
        data_type => 'int',
        description => 'If both city and state, it will search for all entries within # Miles of the city.',
        required => '1',
    },
    'destination_state' => {
        data_type => 'string',
        description => 'If it is an array, we assume a multi state search, and ignore destination_city.',
        required => '1',
    },
    'destination_city' => {
        data_type => 'string',
        description => 'Must be at least 2 characters.',
        required => '1',
    },
    'load_type' => {
        data_type => 'string',
        description => 'A string of comma separated valid trailer types to limit the search.',
        required => '1',
    },
    'end_user_token' => {
        data_type => 'string',
        description => 'Sensitive info like phone numbers won&#39;t be returned without this.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_board_type_origin_state_origin_city_origin_radius_load_type_destination_state_destination_city_get' } = { 
    	summary => 'A convenience method for simple searches.',
        params => $params,
        returns => 'PostBoardTypeResponse',
        };
}
# @return PostBoardTypeResponse
#
sub boards_board_type_origin_state_origin_city_origin_radius_load_type_destination_state_destination_city_get {
    my ($self, %args) = @_;

    # verify the required parameter 'board_type' is set
    unless (exists $args{'board_type'}) {
      croak("Missing the required parameter 'board_type' when calling boards_board_type_origin_state_origin_city_origin_radius_load_type_destination_state_destination_city_get");
    }

    # verify the required parameter 'origin_state' is set
    unless (exists $args{'origin_state'}) {
      croak("Missing the required parameter 'origin_state' when calling boards_board_type_origin_state_origin_city_origin_radius_load_type_destination_state_destination_city_get");
    }

    # verify the required parameter 'origin_city' is set
    unless (exists $args{'origin_city'}) {
      croak("Missing the required parameter 'origin_city' when calling boards_board_type_origin_state_origin_city_origin_radius_load_type_destination_state_destination_city_get");
    }

    # verify the required parameter 'origin_radius' is set
    unless (exists $args{'origin_radius'}) {
      croak("Missing the required parameter 'origin_radius' when calling boards_board_type_origin_state_origin_city_origin_radius_load_type_destination_state_destination_city_get");
    }

    # verify the required parameter 'destination_state' is set
    unless (exists $args{'destination_state'}) {
      croak("Missing the required parameter 'destination_state' when calling boards_board_type_origin_state_origin_city_origin_radius_load_type_destination_state_destination_city_get");
    }

    # verify the required parameter 'destination_city' is set
    unless (exists $args{'destination_city'}) {
      croak("Missing the required parameter 'destination_city' when calling boards_board_type_origin_state_origin_city_origin_radius_load_type_destination_state_destination_city_get");
    }

    # verify the required parameter 'load_type' is set
    unless (exists $args{'load_type'}) {
      croak("Missing the required parameter 'load_type' when calling boards_board_type_origin_state_origin_city_origin_radius_load_type_destination_state_destination_city_get");
    }

    # parse inputs
    my $_resource_path = '/boards/{board_type}/{origin_state}/{origin_city}/{origin_radius}/{load_type}/{destination_state}/{destination_city}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    # path params
    if ( exists $args{'board_type'}) {
        my $_base_variable = "{" . "board_type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'board_type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'origin_state'}) {
        my $_base_variable = "{" . "origin_state" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'origin_state'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'origin_city'}) {
        my $_base_variable = "{" . "origin_city" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'origin_city'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'origin_radius'}) {
        my $_base_variable = "{" . "origin_radius" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'origin_radius'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'destination_state'}) {
        my $_base_variable = "{" . "destination_state" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'destination_state'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'destination_city'}) {
        my $_base_variable = "{" . "destination_city" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'destination_city'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'load_type'}) {
        my $_base_variable = "{" . "load_type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'load_type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PostBoardTypeResponse', $response);
    return $_response_object;
}

#
# boards_board_type_post
#
# Get a board.
# 
# @param SearchBoard $body  (required)
# @param string $board_type This will be specified in the url. Valid types are \&quot;loads\&quot;, and \&quot;trucks\&quot;. (required)
# @param string $end_user_token Sensitive info like phone numbers won&#39;t be returned without this. (optional)
{
    my $params = {
    'body' => {
        data_type => 'SearchBoard',
        description => '',
        required => '1',
    },
    'board_type' => {
        data_type => 'string',
        description => 'This will be specified in the url. Valid types are \&quot;loads\&quot;, and \&quot;trucks\&quot;.',
        required => '1',
    },
    'end_user_token' => {
        data_type => 'string',
        description => 'Sensitive info like phone numbers won&#39;t be returned without this.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_board_type_post' } = { 
    	summary => 'Get a board.',
        params => $params,
        returns => 'PostBoardTypeResponse',
        };
}
# @return PostBoardTypeResponse
#
sub boards_board_type_post {
    my ($self, %args) = @_;

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling boards_board_type_post");
    }

    # verify the required parameter 'board_type' is set
    unless (exists $args{'board_type'}) {
      croak("Missing the required parameter 'board_type' when calling boards_board_type_post");
    }

    # parse inputs
    my $_resource_path = '/boards/{board_type}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    # path params
    if ( exists $args{'board_type'}) {
        my $_base_variable = "{" . "board_type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'board_type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PostBoardTypeResponse', $response);
    return $_response_object;
}

#
# boards_board_type_state_list_get
#
# A convenience method to get totals by state.
# 
# @param string $board_type This will be specified in the url. Valid types are \&quot;loads\&quot;, and \&quot;trucks\&quot;. (required)
{
    my $params = {
    'board_type' => {
        data_type => 'string',
        description => 'This will be specified in the url. Valid types are \&quot;loads\&quot;, and \&quot;trucks\&quot;.',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_board_type_state_list_get' } = { 
    	summary => 'A convenience method to get totals by state.',
        params => $params,
        returns => 'GetStateListResponse',
        };
}
# @return GetStateListResponse
#
sub boards_board_type_state_list_get {
    my ($self, %args) = @_;

    # verify the required parameter 'board_type' is set
    unless (exists $args{'board_type'}) {
      croak("Missing the required parameter 'board_type' when calling boards_board_type_state_list_get");
    }

    # parse inputs
    my $_resource_path = '/boards/{board_type}/state_list';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'board_type'}) {
        my $_base_variable = "{" . "board_type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'board_type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GetStateListResponse', $response);
    return $_response_object;
}

#
# boards_hidden_companies_delete
#
# Mark a company as not hidden.
# 
# @param string $end_user_token Only logged in users can use this feature. (required)
# @param string $company_id The company that need to be marked as not hidden. (required)
{
    my $params = {
    'end_user_token' => {
        data_type => 'string',
        description => 'Only logged in users can use this feature.',
        required => '1',
    },
    'company_id' => {
        data_type => 'string',
        description => 'The company that need to be marked as not hidden.',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_hidden_companies_delete' } = { 
    	summary => 'Mark a company as not hidden.',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub boards_hidden_companies_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'end_user_token' is set
    unless (exists $args{'end_user_token'}) {
      croak("Missing the required parameter 'end_user_token' when calling boards_hidden_companies_delete");
    }

    # verify the required parameter 'company_id' is set
    unless (exists $args{'company_id'}) {
      croak("Missing the required parameter 'company_id' when calling boards_hidden_companies_delete");
    }

    # parse inputs
    my $_resource_path = '/boards/hidden_companies';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # query params
    if ( exists $args{'company_id'}) {
        $query_params->{'company_id'} = $self->{api_client}->to_query_value($args{'company_id'});
    }

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# boards_hidden_companies_get
#
# Get a list of companies that should be hidden.
# 
# @param string $end_user_token Only logged in users can use this feature. (required)
# @param ARRAY[string] $company_name A list of id&#39;s to check if any should be visually hidden. (required)
{
    my $params = {
    'end_user_token' => {
        data_type => 'string',
        description => 'Only logged in users can use this feature.',
        required => '1',
    },
    'company_name' => {
        data_type => 'ARRAY[string]',
        description => 'A list of id&#39;s to check if any should be visually hidden.',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_hidden_companies_get' } = { 
    	summary => 'Get a list of companies that should be hidden.',
        params => $params,
        returns => 'GetHiddenCompaniesResponse',
        };
}
# @return GetHiddenCompaniesResponse
#
sub boards_hidden_companies_get {
    my ($self, %args) = @_;

    # verify the required parameter 'end_user_token' is set
    unless (exists $args{'end_user_token'}) {
      croak("Missing the required parameter 'end_user_token' when calling boards_hidden_companies_get");
    }

    # verify the required parameter 'company_name' is set
    unless (exists $args{'company_name'}) {
      croak("Missing the required parameter 'company_name' when calling boards_hidden_companies_get");
    }

    # parse inputs
    my $_resource_path = '/boards/hidden_companies';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # query params
    if ( exists $args{'company_name'}) {
        $query_params->{'company_name'} = $self->{api_client}->to_query_value($args{'company_name'});
    }

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GetHiddenCompaniesResponse', $response);
    return $_response_object;
}

#
# boards_hidden_companies_patch
#
# Toggle one or more company between hidden and unhidden.
# 
# @param string $end_user_token Only logged in users can use this feature. (required)
# @param ToggleHiddenCompanies $body  (required)
{
    my $params = {
    'end_user_token' => {
        data_type => 'string',
        description => 'Only logged in users can use this feature.',
        required => '1',
    },
    'body' => {
        data_type => 'ToggleHiddenCompanies',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_hidden_companies_patch' } = { 
    	summary => 'Toggle one or more company between hidden and unhidden.',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub boards_hidden_companies_patch {
    my ($self, %args) = @_;

    # verify the required parameter 'end_user_token' is set
    unless (exists $args{'end_user_token'}) {
      croak("Missing the required parameter 'end_user_token' when calling boards_hidden_companies_patch");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling boards_hidden_companies_patch");
    }

    # parse inputs
    my $_resource_path = '/boards/hidden_companies';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# boards_hidden_companies_post
#
# Mark a set of companies as hidden.
# 
# @param string $end_user_token Only logged in users can use this feature. (required)
# @param MarkHiddenCompanies $body  (required)
{
    my $params = {
    'end_user_token' => {
        data_type => 'string',
        description => 'Only logged in users can use this feature.',
        required => '1',
    },
    'body' => {
        data_type => 'MarkHiddenCompanies',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_hidden_companies_post' } = { 
    	summary => 'Mark a set of companies as hidden.',
        params => $params,
        returns => 'PostHiddenCompaniesResponse',
        };
}
# @return PostHiddenCompaniesResponse
#
sub boards_hidden_companies_post {
    my ($self, %args) = @_;

    # verify the required parameter 'end_user_token' is set
    unless (exists $args{'end_user_token'}) {
      croak("Missing the required parameter 'end_user_token' when calling boards_hidden_companies_post");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling boards_hidden_companies_post");
    }

    # parse inputs
    my $_resource_path = '/boards/hidden_companies';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PostHiddenCompaniesResponse', $response);
    return $_response_object;
}

#
# boards_hidden_entries_delete
#
# Mark a set of entries as not hidden.
# 
# @param string $end_user_token Only logged in users can use this feature. (required)
# @param string $entry_id The entry that need to be marked as not hidden.  (required)
{
    my $params = {
    'end_user_token' => {
        data_type => 'string',
        description => 'Only logged in users can use this feature.',
        required => '1',
    },
    'entry_id' => {
        data_type => 'string',
        description => 'The entry that need to be marked as not hidden. ',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_hidden_entries_delete' } = { 
    	summary => 'Mark a set of entries as not hidden.',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub boards_hidden_entries_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'end_user_token' is set
    unless (exists $args{'end_user_token'}) {
      croak("Missing the required parameter 'end_user_token' when calling boards_hidden_entries_delete");
    }

    # verify the required parameter 'entry_id' is set
    unless (exists $args{'entry_id'}) {
      croak("Missing the required parameter 'entry_id' when calling boards_hidden_entries_delete");
    }

    # parse inputs
    my $_resource_path = '/boards/hidden_entries';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # query params
    if ( exists $args{'entry_id'}) {
        $query_params->{'entry_id'} = $self->{api_client}->to_query_value($args{'entry_id'});
    }

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# boards_hidden_entries_get
#
# Get a list of entries that should be hidden.
# 
# @param string $end_user_token Only logged in users can use this feature. (required)
# @param ARRAY[string] $entry_id A list of id&#39;s to check if any should be visually hidden. (required)
{
    my $params = {
    'end_user_token' => {
        data_type => 'string',
        description => 'Only logged in users can use this feature.',
        required => '1',
    },
    'entry_id' => {
        data_type => 'ARRAY[string]',
        description => 'A list of id&#39;s to check if any should be visually hidden.',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_hidden_entries_get' } = { 
    	summary => 'Get a list of entries that should be hidden.',
        params => $params,
        returns => 'GetHiddenEntries',
        };
}
# @return GetHiddenEntries
#
sub boards_hidden_entries_get {
    my ($self, %args) = @_;

    # verify the required parameter 'end_user_token' is set
    unless (exists $args{'end_user_token'}) {
      croak("Missing the required parameter 'end_user_token' when calling boards_hidden_entries_get");
    }

    # verify the required parameter 'entry_id' is set
    unless (exists $args{'entry_id'}) {
      croak("Missing the required parameter 'entry_id' when calling boards_hidden_entries_get");
    }

    # parse inputs
    my $_resource_path = '/boards/hidden_entries';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # query params
    if ( exists $args{'entry_id'}) {
        $query_params->{'entry_id'} = $self->{api_client}->to_query_value($args{'entry_id'});
    }

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GetHiddenEntries', $response);
    return $_response_object;
}

#
# boards_hidden_entries_patch
#
# Toggle one or more entry between hidden and unhidden.
# 
# @param string $end_user_token Only logged in users can use this feature. (required)
# @param ToggleHiddenEntries $body  (required)
{
    my $params = {
    'end_user_token' => {
        data_type => 'string',
        description => 'Only logged in users can use this feature.',
        required => '1',
    },
    'body' => {
        data_type => 'ToggleHiddenEntries',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_hidden_entries_patch' } = { 
    	summary => 'Toggle one or more entry between hidden and unhidden.',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub boards_hidden_entries_patch {
    my ($self, %args) = @_;

    # verify the required parameter 'end_user_token' is set
    unless (exists $args{'end_user_token'}) {
      croak("Missing the required parameter 'end_user_token' when calling boards_hidden_entries_patch");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling boards_hidden_entries_patch");
    }

    # parse inputs
    my $_resource_path = '/boards/hidden_entries';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# boards_hidden_entries_post
#
# Mark a set of entries as hidden.
# 
# @param string $end_user_token Only logged in users can use this feature. (required)
# @param MarkHiddenEntries $body  (required)
{
    my $params = {
    'end_user_token' => {
        data_type => 'string',
        description => 'Only logged in users can use this feature.',
        required => '1',
    },
    'body' => {
        data_type => 'MarkHiddenEntries',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_hidden_entries_post' } = { 
    	summary => 'Mark a set of entries as hidden.',
        params => $params,
        returns => 'PostHiddenEntriesResponse',
        };
}
# @return PostHiddenEntriesResponse
#
sub boards_hidden_entries_post {
    my ($self, %args) = @_;

    # verify the required parameter 'end_user_token' is set
    unless (exists $args{'end_user_token'}) {
      croak("Missing the required parameter 'end_user_token' when calling boards_hidden_entries_post");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling boards_hidden_entries_post");
    }

    # parse inputs
    my $_resource_path = '/boards/hidden_entries';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PostHiddenEntriesResponse', $response);
    return $_response_object;
}

#
# boards_notes_delete
#
# Delete a note.
# 
# @param string $end_user_token Only logged in users can use this feature. (required)
# @param string $note_id The entry to associate the note with.  (required)
{
    my $params = {
    'end_user_token' => {
        data_type => 'string',
        description => 'Only logged in users can use this feature.',
        required => '1',
    },
    'note_id' => {
        data_type => 'string',
        description => 'The entry to associate the note with. ',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_notes_delete' } = { 
    	summary => 'Delete a note.',
        params => $params,
        returns => 'DeleteBoardsNotesResponse',
        };
}
# @return DeleteBoardsNotesResponse
#
sub boards_notes_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'end_user_token' is set
    unless (exists $args{'end_user_token'}) {
      croak("Missing the required parameter 'end_user_token' when calling boards_notes_delete");
    }

    # verify the required parameter 'note_id' is set
    unless (exists $args{'note_id'}) {
      croak("Missing the required parameter 'note_id' when calling boards_notes_delete");
    }

    # parse inputs
    my $_resource_path = '/boards/notes';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # query params
    if ( exists $args{'note_id'}) {
        $query_params->{'note_id'} = $self->{api_client}->to_query_value($args{'note_id'});
    }

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('DeleteBoardsNotesResponse', $response);
    return $_response_object;
}

#
# boards_notes_get
#
# Get notes that this user has written.
# 
# @param string $end_user_token Only logged in users can use this feature. (required)
# @param ARRAY[string] $entry_id Optionally just check if certain loads have notes associated with them.  (optional)
{
    my $params = {
    'end_user_token' => {
        data_type => 'string',
        description => 'Only logged in users can use this feature.',
        required => '1',
    },
    'entry_id' => {
        data_type => 'ARRAY[string]',
        description => 'Optionally just check if certain loads have notes associated with them. ',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_notes_get' } = { 
    	summary => 'Get notes that this user has written.',
        params => $params,
        returns => 'GetBoardsNotesResponse',
        };
}
# @return GetBoardsNotesResponse
#
sub boards_notes_get {
    my ($self, %args) = @_;

    # verify the required parameter 'end_user_token' is set
    unless (exists $args{'end_user_token'}) {
      croak("Missing the required parameter 'end_user_token' when calling boards_notes_get");
    }

    # parse inputs
    my $_resource_path = '/boards/notes';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # query params
    if ( exists $args{'entry_id'}) {
        $query_params->{'entry_id'} = $self->{api_client}->to_query_value($args{'entry_id'});
    }

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GetBoardsNotesResponse', $response);
    return $_response_object;
}

#
# boards_notes_patch
#
# Update a note.
# 
# @param string $end_user_token Only logged in users can use this feature. (required)
# @param UpdateNotes $body  (required)
{
    my $params = {
    'end_user_token' => {
        data_type => 'string',
        description => 'Only logged in users can use this feature.',
        required => '1',
    },
    'body' => {
        data_type => 'UpdateNotes',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_notes_patch' } = { 
    	summary => 'Update a note.',
        params => $params,
        returns => 'PatchBoardsNotesResponse',
        };
}
# @return PatchBoardsNotesResponse
#
sub boards_notes_patch {
    my ($self, %args) = @_;

    # verify the required parameter 'end_user_token' is set
    unless (exists $args{'end_user_token'}) {
      croak("Missing the required parameter 'end_user_token' when calling boards_notes_patch");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling boards_notes_patch");
    }

    # parse inputs
    my $_resource_path = '/boards/notes';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PatchBoardsNotesResponse', $response);
    return $_response_object;
}

#
# boards_notes_post
#
# Create a new note.
# 
# @param string $end_user_token Only logged in users can use this feature. (required)
# @param CreateNotes $body  (required)
{
    my $params = {
    'end_user_token' => {
        data_type => 'string',
        description => 'Only logged in users can use this feature.',
        required => '1',
    },
    'body' => {
        data_type => 'CreateNotes',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'boards_notes_post' } = { 
    	summary => 'Create a new note.',
        params => $params,
        returns => 'PostBoardsNotesResponse',
        };
}
# @return PostBoardsNotesResponse
#
sub boards_notes_post {
    my ($self, %args) = @_;

    # verify the required parameter 'end_user_token' is set
    unless (exists $args{'end_user_token'}) {
      croak("Missing the required parameter 'end_user_token' when calling boards_notes_post");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling boards_notes_post");
    }

    # parse inputs
    my $_resource_path = '/boards/notes';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # header params
    if ( exists $args{'end_user_token'}) {
        $header_params->{'end-user-token'} = $self->{api_client}->to_header_value($args{'end_user_token'});
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PostBoardsNotesResponse', $response);
    return $_response_object;
}

1;
